{"ast":null,"code":"import _toConsumableArray from \"/Users/frida/teamdagarna/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/frida/teamdagarna/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/frida/teamdagarna/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { InjectionToken } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, queueScheduler, asyncScheduler } from 'rxjs';\nimport { subscribeOn, observeOn, tap } from 'rxjs/operators';\nexport var RealtimeDatabaseURL = /*#__PURE__*/new InjectionToken('angularfire2.realtimeDatabaseURL');\nexport var DATABASE_URL = RealtimeDatabaseURL;\n\nfunction noop() {}\n\nexport var ɵZoneScheduler = /*#__PURE__*/function () {\n  function ɵZoneScheduler(zone) {\n    var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : queueScheduler;\n\n    _classCallCheck(this, ɵZoneScheduler);\n\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n\n  _createClass(ɵZoneScheduler, [{\n    key: \"now\",\n    value: function now() {\n      return this.delegate.now();\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule(work, delay, state) {\n      var targetZone = this.zone;\n\n      var workInZone = function workInZone(state) {\n        var _this = this;\n\n        targetZone.runGuarded(function () {\n          work.apply(_this, [state]);\n        });\n      };\n\n      return this.delegate.schedule(workInZone, delay, state);\n    }\n  }]);\n\n  return ɵZoneScheduler;\n}();\nexport var ɵBlockUntilFirstOperator = /*#__PURE__*/function () {\n  function ɵBlockUntilFirstOperator(zone) {\n    _classCallCheck(this, ɵBlockUntilFirstOperator);\n\n    this.zone = zone;\n    this.task = null;\n  }\n\n  _createClass(ɵBlockUntilFirstOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      var unscheduleTask = this.unscheduleTask.bind(this);\n      this.task = this.zone.run(function () {\n        return Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n      });\n      return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);\n    }\n  }, {\n    key: \"unscheduleTask\",\n    value: function unscheduleTask() {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }\n  }]);\n\n  return ɵBlockUntilFirstOperator;\n}();\nexport var ɵAngularFireSchedulers = /*#__PURE__*/_createClass(function ɵAngularFireSchedulers(ngZone) {\n  _classCallCheck(this, ɵAngularFireSchedulers);\n\n  this.ngZone = ngZone;\n  this.outsideAngular = ngZone.runOutsideAngular(function () {\n    return new ɵZoneScheduler(Zone.current);\n  });\n  this.insideAngular = ngZone.run(function () {\n    return new ɵZoneScheduler(Zone.current, asyncScheduler);\n  });\n});\nexport function ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {\n  return function keepUnstableUntilFirst(obs$) {\n    if (isPlatformServer(platformId)) {\n      obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n    }\n\n    return obs$.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n  };\n}\nexport var runOutsideAngular = function runOutsideAngular(zone) {\n  return function (obs$) {\n    return new Observable(function (subscriber) {\n      return zone.runOutsideAngular(function () {\n        runInZone(zone)(obs$).subscribe(subscriber);\n      });\n    });\n  };\n};\nexport var runInZone = function runInZone(zone) {\n  return function (obs$) {\n    return new Observable(function (subscriber) {\n      return obs$.subscribe(function (value) {\n        return zone.run(function () {\n          return subscriber.next(value);\n        });\n      }, function (error) {\n        return zone.run(function () {\n          return subscriber.error(error);\n        });\n      }, function () {\n        return zone.run(function () {\n          return subscriber.complete();\n        });\n      });\n    });\n  };\n};\nexport var FirebaseZoneScheduler = /*#__PURE__*/function () {\n  function FirebaseZoneScheduler(zone, platformId) {\n    _classCallCheck(this, FirebaseZoneScheduler);\n\n    this.zone = zone;\n    this.platformId = platformId;\n  }\n\n  _createClass(FirebaseZoneScheduler, [{\n    key: \"schedule\",\n    value: function schedule() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.zone.runGuarded(function () {\n        return queueScheduler.schedule.apply(queueScheduler, args);\n      });\n    }\n  }, {\n    key: \"keepUnstableUntilFirst\",\n    value: function keepUnstableUntilFirst(obs$) {\n      if (isPlatformServer(this.platformId)) {\n        return new Observable(function (subscriber) {\n          var noop = function noop() {};\n\n          var task = Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n          obs$.subscribe(function (next) {\n            if (task.state === 'scheduled') {\n              task.invoke();\n            }\n\n            ;\n            subscriber.next(next);\n          }, function (error) {\n            if (task.state === 'scheduled') {\n              task.invoke();\n            }\n\n            subscriber.error(error);\n          }, function () {\n            if (task.state === 'scheduled') {\n              task.invoke();\n            }\n\n            subscriber.complete();\n          });\n        });\n      } else {\n        return obs$;\n      }\n    }\n  }, {\n    key: \"runOutsideAngular\",\n    value: function runOutsideAngular(obs$) {\n      var _this2 = this;\n\n      return new Observable(function (subscriber) {\n        return _this2.zone.runOutsideAngular(function () {\n          return obs$.subscribe(function (value) {\n            return _this2.zone.run(function () {\n              return subscriber.next(value);\n            });\n          }, function (error) {\n            return _this2.zone.run(function () {\n              return subscriber.error(error);\n            });\n          }, function () {\n            return _this2.zone.run(function () {\n              return subscriber.complete();\n            });\n          });\n        });\n      });\n    }\n  }]);\n\n  return FirebaseZoneScheduler;\n}();\nvar noopFunctions = ['ngOnDestroy'];\nexport var ɵlazySDKProxy = function ɵlazySDKProxy(klass, observable, zone) {\n  return new Proxy(klass, {\n    get: function get(_, name) {\n      return zone.runOutsideAngular(function () {\n        if (klass[name]) {\n          return klass[name];\n        }\n\n        if (noopFunctions.includes(name)) {\n          return function () {};\n        }\n\n        var promise = observable.toPromise().then(function (mod) {\n          var ret = mod && mod[name];\n\n          if (typeof ret == 'function') {\n            return ret.bind(mod);\n          } else if (ret && ret.then) {\n            return ret.then(function (res) {\n              return zone.run(function () {\n                return res;\n              });\n            });\n          } else {\n            return zone.run(function () {\n              return ret;\n            });\n          }\n        });\n        return new Proxy(function () {\n          return undefined;\n        }, {\n          get: function get(_, name) {\n            return promise[name];\n          },\n          apply: function apply(self, _, args) {\n            return promise.then(function (it) {\n              return it && it.apply(void 0, _toConsumableArray(args));\n            });\n          }\n        });\n      });\n    }\n  });\n}; //# sourceMappingURL=angularfire2.js.map","map":null,"metadata":{},"sourceType":"module"}