{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { escapeFacets, TAG_PLACEHOLDER, TAG_REPLACEMENT, checkRendering, createDocumentationMessageGenerator, createSendEventForFacet, noop } from \"../../lib/utils/index.js\";\nvar withUsage = createDocumentationMessageGenerator({\n  name: 'refinement-list',\n  connector: true\n});\nvar DEFAULT_SORT = ['isRefined', 'count:desc', 'name:asc'];\n/**\n * **RefinementList** connector provides the logic to build a custom widget that\n * will let the user filter the results based on the values of a specific facet.\n *\n * **Requirement:** the attribute passed as `attribute` must be present in\n * attributesForFaceting of the searched index.\n *\n * This connector provides:\n * - a `refine()` function to select an item.\n * - a `toggleShowMore()` function to display more or less items\n * - a `searchForItems()` function to search within the items.\n */\n\nvar connectRefinementList = function connectRefinementList(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  checkRendering(renderFn, withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        attribute = _ref.attribute,\n        _ref$operator = _ref.operator,\n        operator = _ref$operator === void 0 ? 'or' : _ref$operator,\n        _ref$limit = _ref.limit,\n        limit = _ref$limit === void 0 ? 10 : _ref$limit,\n        _ref$showMore = _ref.showMore,\n        showMore = _ref$showMore === void 0 ? false : _ref$showMore,\n        _ref$showMoreLimit = _ref.showMoreLimit,\n        showMoreLimit = _ref$showMoreLimit === void 0 ? 20 : _ref$showMoreLimit,\n        _ref$sortBy = _ref.sortBy,\n        sortBy = _ref$sortBy === void 0 ? DEFAULT_SORT : _ref$sortBy,\n        _ref$escapeFacetValue = _ref.escapeFacetValues,\n        escapeFacetValues = _ref$escapeFacetValue === void 0 ? true : _ref$escapeFacetValue,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    if (!attribute) {\n      throw new Error(withUsage('The `attribute` option is required.'));\n    }\n\n    if (!/^(and|or)$/.test(operator)) {\n      throw new Error(withUsage(\"The `operator` must one of: `\\\"and\\\"`, `\\\"or\\\"` (got \\\"\".concat(operator, \"\\\").\")));\n    }\n\n    if (showMore === true && showMoreLimit <= limit) {\n      throw new Error(withUsage('`showMoreLimit` should be greater than `limit`.'));\n    }\n\n    var formatItems = function formatItems(_ref2) {\n      var label = _ref2.name,\n          item = _objectWithoutProperties(_ref2, [\"name\"]);\n\n      return _objectSpread(_objectSpread({}, item), {}, {\n        label: label,\n        value: label,\n        highlighted: label\n      });\n    };\n\n    var lastResultsFromMainSearch;\n    var lastItemsFromMainSearch = [];\n    var hasExhaustiveItems = true;\n    var triggerRefine;\n    var sendEvent;\n    var isShowingMore = false; // Provide the same function to the `renderFn` so that way the user\n    // has to only bind it once when `isFirstRendering` for instance\n\n    var toggleShowMore = function toggleShowMore() {};\n\n    function cachedToggleShowMore() {\n      toggleShowMore();\n    }\n\n    function createToggleShowMore(renderOptions, widget) {\n      return function () {\n        isShowingMore = !isShowingMore;\n        widget.render(renderOptions);\n      };\n    }\n\n    function getLimit() {\n      return isShowingMore ? showMoreLimit : limit;\n    }\n\n    var searchForFacetValues = function searchForFacetValues() {\n      return function () {};\n    };\n\n    var createSearchForFacetValues = function createSearchForFacetValues(helper, widget) {\n      return function (renderOptions) {\n        return function (query) {\n          var instantSearchInstance = renderOptions.instantSearchInstance,\n              searchResults = renderOptions.results;\n\n          if (query === '' && lastItemsFromMainSearch) {\n            // render with previous data from the helper.\n            renderFn(_objectSpread(_objectSpread({}, widget.getWidgetRenderState(_objectSpread(_objectSpread({}, renderOptions), {}, {\n              results: lastResultsFromMainSearch\n            }))), {}, {\n              instantSearchInstance: instantSearchInstance\n            }), false);\n          } else {\n            var tags = {\n              highlightPreTag: escapeFacetValues ? TAG_PLACEHOLDER.highlightPreTag : TAG_REPLACEMENT.highlightPreTag,\n              highlightPostTag: escapeFacetValues ? TAG_PLACEHOLDER.highlightPostTag : TAG_REPLACEMENT.highlightPostTag\n            };\n            helper.searchForFacetValues(attribute, query, // We cap the `maxFacetHits` value to 100 because the Algolia API\n            // doesn't support a greater number.\n            // See https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits/\n            Math.min(getLimit(), 100), tags).then(function (results) {\n              var facetValues = escapeFacetValues ? escapeFacets(results.facetHits) : results.facetHits;\n              var normalizedFacetValues = transformItems(facetValues.map(function (_ref3) {\n                var value = _ref3.value,\n                    item = _objectWithoutProperties(_ref3, [\"value\"]);\n\n                return _objectSpread(_objectSpread({}, item), {}, {\n                  value: value,\n                  label: value\n                });\n              }), {\n                results: searchResults\n              });\n              renderFn(_objectSpread(_objectSpread({}, widget.getWidgetRenderState(_objectSpread(_objectSpread({}, renderOptions), {}, {\n                results: lastResultsFromMainSearch\n              }))), {}, {\n                items: normalizedFacetValues,\n                canToggleShowMore: false,\n                canRefine: true,\n                isFromSearch: true,\n                instantSearchInstance: instantSearchInstance\n              }), false);\n            });\n          }\n        };\n      };\n    };\n\n    return {\n      $$type: 'ais.refinementList',\n      init: function init(initOptions) {\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return _objectSpread(_objectSpread({}, renderState), {}, {\n          refinementList: _objectSpread(_objectSpread({}, renderState.refinementList), {}, _defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(renderOptions) {\n        var results = renderOptions.results,\n            state = renderOptions.state,\n            _createURL = renderOptions.createURL,\n            instantSearchInstance = renderOptions.instantSearchInstance,\n            helper = renderOptions.helper;\n        var items = [];\n        var facetValues = [];\n\n        if (!sendEvent || !triggerRefine || !searchForFacetValues) {\n          sendEvent = createSendEventForFacet({\n            instantSearchInstance: instantSearchInstance,\n            helper: helper,\n            attribute: attribute,\n            widgetType: this.$$type\n          });\n\n          triggerRefine = function triggerRefine(facetValue) {\n            sendEvent('click', facetValue);\n            helper.toggleFacetRefinement(attribute, facetValue).search();\n          };\n\n          searchForFacetValues = createSearchForFacetValues(helper, this);\n        }\n\n        if (results) {\n          var values = results.getFacetValues(attribute, {\n            sortBy: sortBy,\n            facetOrdering: sortBy === DEFAULT_SORT\n          });\n          facetValues = values && Array.isArray(values) ? values : [];\n          items = transformItems(facetValues.slice(0, getLimit()).map(formatItems), {\n            results: results\n          });\n          var maxValuesPerFacetConfig = state.maxValuesPerFacet;\n          var currentLimit = getLimit(); // If the limit is the max number of facet retrieved it is impossible to know\n          // if the facets are exhaustive. The only moment we are sure it is exhaustive\n          // is when it is strictly under the number requested unless we know that another\n          // widget has requested more values (maxValuesPerFacet > getLimit()).\n          // Because this is used for making the search of facets unable or not, it is important\n          // to be conservative here.\n\n          hasExhaustiveItems = maxValuesPerFacetConfig > currentLimit ? facetValues.length <= currentLimit : facetValues.length < currentLimit;\n          lastResultsFromMainSearch = results;\n          lastItemsFromMainSearch = items;\n\n          if (renderOptions.results) {\n            toggleShowMore = createToggleShowMore(renderOptions, this);\n          }\n        } // Do not mistake searchForFacetValues and searchFacetValues which is the actual search\n        // function\n\n\n        var searchFacetValues = searchForFacetValues && searchForFacetValues(renderOptions);\n        var canShowLess = isShowingMore && lastItemsFromMainSearch.length > limit;\n        var canShowMore = showMore && !hasExhaustiveItems;\n        var canToggleShowMore = canShowLess || canShowMore;\n        return {\n          createURL: function createURL(facetValue) {\n            return _createURL(state.resetPage().toggleFacetRefinement(attribute, facetValue));\n          },\n          items: items,\n          refine: triggerRefine,\n          searchForItems: searchFacetValues,\n          isFromSearch: false,\n          canRefine: items.length > 0,\n          widgetParams: widgetParams,\n          isShowingMore: isShowingMore,\n          canToggleShowMore: canToggleShowMore,\n          toggleShowMore: cachedToggleShowMore,\n          sendEvent: sendEvent,\n          hasExhaustiveItems: hasExhaustiveItems\n        };\n      },\n      dispose: function dispose(_ref4) {\n        var state = _ref4.state;\n        unmountFn();\n        var withoutMaxValuesPerFacet = state.setQueryParameter('maxValuesPerFacet', undefined);\n\n        if (operator === 'and') {\n          return withoutMaxValuesPerFacet.removeFacet(attribute);\n        }\n\n        return withoutMaxValuesPerFacet.removeDisjunctiveFacet(attribute);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {\n        var searchParameters = _ref5.searchParameters;\n        var values = operator === 'or' ? searchParameters.getDisjunctiveRefinements(attribute) : searchParameters.getConjunctiveRefinements(attribute);\n\n        if (!values.length) {\n          return uiState;\n        }\n\n        return _objectSpread(_objectSpread({}, uiState), {}, {\n          refinementList: _objectSpread(_objectSpread({}, uiState.refinementList), {}, _defineProperty({}, attribute, values))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {\n        var uiState = _ref6.uiState;\n        var isDisjunctive = operator === 'or';\n        var values = uiState.refinementList && uiState.refinementList[attribute];\n        var withoutRefinements = searchParameters.clearRefinements(attribute);\n        var withFacetConfiguration = isDisjunctive ? withoutRefinements.addDisjunctiveFacet(attribute) : withoutRefinements.addFacet(attribute);\n        var currentMaxValuesPerFacet = withFacetConfiguration.maxValuesPerFacet || 0;\n        var nextMaxValuesPerFacet = Math.max(currentMaxValuesPerFacet, showMore ? showMoreLimit : limit);\n        var withMaxValuesPerFacet = withFacetConfiguration.setQueryParameter('maxValuesPerFacet', nextMaxValuesPerFacet);\n\n        if (!values) {\n          var key = isDisjunctive ? 'disjunctiveFacetsRefinements' : 'facetsRefinements';\n          return withMaxValuesPerFacet.setQueryParameters(_defineProperty({}, key, _objectSpread(_objectSpread({}, withMaxValuesPerFacet[key]), {}, _defineProperty({}, attribute, []))));\n        }\n\n        return values.reduce(function (parameters, value) {\n          return isDisjunctive ? parameters.addDisjunctiveFacetRefinement(attribute, value) : parameters.addFacetRefinement(attribute, value);\n        }, withMaxValuesPerFacet);\n      }\n    };\n  };\n};\n\nexport default connectRefinementList;","map":null,"metadata":{},"sourceType":"module"}