{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { checkRendering, createDocumentationMessageGenerator, getWidgetAttribute, noop, warning } from \"../../lib/utils/index.js\";\nvar withUsage = createDocumentationMessageGenerator({\n  name: 'dynamic-widgets',\n  connector: true\n});\nvar MAX_WILDCARD_FACETS = 20;\n\nvar connectDynamicWidgets = function connectDynamicWidgets(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  checkRendering(renderFn, withUsage());\n  return function (widgetParams) {\n    var widgets = widgetParams.widgets,\n        _widgetParams$maxValu = widgetParams.maxValuesPerFacet,\n        maxValuesPerFacet = _widgetParams$maxValu === void 0 ? 20 : _widgetParams$maxValu,\n        _widgetParams$facets = widgetParams.facets,\n        facets = _widgetParams$facets === void 0 ? ['*'] : _widgetParams$facets,\n        _widgetParams$transfo = widgetParams.transformItems,\n        transformItems = _widgetParams$transfo === void 0 ? function (items) {\n      return items;\n    } : _widgetParams$transfo,\n        fallbackWidget = widgetParams.fallbackWidget;\n\n    if (!(widgets && Array.isArray(widgets) && widgets.every(function (widget) {\n      return _typeof(widget) === 'object';\n    }))) {\n      throw new Error(withUsage('The `widgets` option expects an array of widgets.'));\n    }\n\n    if (!(Array.isArray(facets) && facets.length <= 1 && (facets[0] === '*' || facets[0] === undefined))) {\n      throw new Error(withUsage(\"The `facets` option only accepts [] or [\\\"*\\\"], you passed \".concat(JSON.stringify(facets))));\n    }\n\n    var localWidgets = new Map();\n    return {\n      $$type: 'ais.dynamicWidgets',\n      init: function init(initOptions) {\n        widgets.forEach(function (widget) {\n          var attribute = getWidgetAttribute(widget, initOptions);\n          localWidgets.set(attribute, {\n            widget: widget,\n            isMounted: false\n          });\n        });\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var parent = renderOptions.parent;\n        var renderState = this.getWidgetRenderState(renderOptions);\n        var widgetsToUnmount = [];\n        var widgetsToMount = [];\n\n        if (fallbackWidget) {\n          renderState.attributesToRender.forEach(function (attribute) {\n            if (!localWidgets.has(attribute)) {\n              var widget = fallbackWidget({\n                attribute: attribute\n              });\n              localWidgets.set(attribute, {\n                widget: widget,\n                isMounted: false\n              });\n            }\n          });\n        }\n\n        localWidgets.forEach(function (_ref, attribute) {\n          var widget = _ref.widget,\n              isMounted = _ref.isMounted;\n          var shouldMount = renderState.attributesToRender.indexOf(attribute) > -1;\n\n          if (!isMounted && shouldMount) {\n            widgetsToMount.push(widget);\n            localWidgets.set(attribute, {\n              widget: widget,\n              isMounted: true\n            });\n          } else if (isMounted && !shouldMount) {\n            widgetsToUnmount.push(widget);\n            localWidgets.set(attribute, {\n              widget: widget,\n              isMounted: false\n            });\n          }\n        });\n        parent.addWidgets(widgetsToMount); // make sure this only happens after the regular render, otherwise it\n        // happens too quick, since render is \"deferred\" for the next microtask,\n        // so this needs to be a whole task later\n\n        setTimeout(function () {\n          return parent.removeWidgets(widgetsToUnmount);\n        }, 0);\n        renderFn(_objectSpread(_objectSpread({}, renderState), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref2) {\n        var parent = _ref2.parent;\n        var toRemove = [];\n        localWidgets.forEach(function (_ref3) {\n          var widget = _ref3.widget,\n              isMounted = _ref3.isMounted;\n\n          if (isMounted) {\n            toRemove.push(widget);\n          }\n        });\n        parent.removeWidgets(toRemove);\n        unmountFn();\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(state) {\n        // broadening the scope of facets to avoid conflict between never and *\n        return facets.reduce(function (acc, curr) {\n          return acc.addFacet(curr);\n        }, state.setQueryParameters({\n          maxValuesPerFacet: Math.max(maxValuesPerFacet || 0, state.maxValuesPerFacet || 0)\n        }));\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return _objectSpread(_objectSpread({}, renderState), {}, {\n          dynamicWidgets: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref4) {\n        var _results$renderingCon, _results$renderingCon2, _results$renderingCon3, _results$renderingCon4;\n\n        var results = _ref4.results,\n            state = _ref4.state;\n\n        if (!results) {\n          return {\n            attributesToRender: [],\n            widgetParams: widgetParams\n          };\n        }\n\n        var attributesToRender = transformItems((_results$renderingCon = (_results$renderingCon2 = results.renderingContent) === null || _results$renderingCon2 === void 0 ? void 0 : (_results$renderingCon3 = _results$renderingCon2.facetOrdering) === null || _results$renderingCon3 === void 0 ? void 0 : (_results$renderingCon4 = _results$renderingCon3.facets) === null || _results$renderingCon4 === void 0 ? void 0 : _results$renderingCon4.order) !== null && _results$renderingCon !== void 0 ? _results$renderingCon : [], {\n          results: results\n        });\n\n        if (!Array.isArray(attributesToRender)) {\n          throw new Error(withUsage('The `transformItems` option expects a function that returns an Array.'));\n        }\n\n        process.env.NODE_ENV === 'development' ? warning(maxValuesPerFacet >= (state.maxValuesPerFacet || 0), \"The maxValuesPerFacet set by dynamic widgets (\".concat(maxValuesPerFacet, \") is smaller than one of the limits set by a widget (\").concat(state.maxValuesPerFacet, \"). This causes a mismatch in query parameters and thus an extra network request when that widget is mounted.\")) : void 0;\n        process.env.NODE_ENV === 'development' ? warning(attributesToRender.length <= MAX_WILDCARD_FACETS || widgetParams.facets !== undefined, \"More than \".concat(MAX_WILDCARD_FACETS, \" facets are requested to be displayed without explicitly setting which facets to retrieve. This could have a performance impact. Set \\\"facets\\\" to [] to do two smaller network requests, or explicitly to ['*'] to avoid this warning.\")) : void 0;\n        return {\n          attributesToRender: attributesToRender,\n          widgetParams: widgetParams\n        };\n      }\n    };\n  };\n};\n\nexport default connectDynamicWidgets;","map":null,"metadata":{},"sourceType":"module"}