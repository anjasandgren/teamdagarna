{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport hogan from 'hogan.js'; // We add all our template helper methods to the template as lambdas. Note\n// that lambdas in Mustache are supposed to accept a second argument of\n// `render` to get the rendered value, not the literal `{{value}}`. But\n// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).\n\nfunction transformHelpersToHogan() {\n  var helpers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var compileOptions = arguments.length > 1 ? arguments[1] : undefined;\n  var data = arguments.length > 2 ? arguments[2] : undefined;\n  return Object.keys(helpers).reduce(function (acc, helperKey) {\n    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, helperKey, function () {\n      var _this = this;\n\n      return function (text) {\n        var render = function render(value) {\n          return hogan.compile(value, compileOptions).render(_this);\n        };\n\n        return helpers[helperKey].call(data, text, render);\n      };\n    }));\n  }, {});\n}\n\nfunction renderTemplate(_ref) {\n  var templates = _ref.templates,\n      templateKey = _ref.templateKey,\n      compileOptions = _ref.compileOptions,\n      helpers = _ref.helpers,\n      data = _ref.data,\n      bindEvent = _ref.bindEvent;\n  var template = templates[templateKey];\n\n  if (typeof template !== 'string' && typeof template !== 'function') {\n    throw new Error(\"Template must be 'string' or 'function', was '\".concat(_typeof(template), \"' (key: \").concat(templateKey, \")\"));\n  }\n\n  if (typeof template === 'function') {\n    return template(data, bindEvent);\n  }\n\n  var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);\n  return hogan.compile(template, compileOptions).render(_objectSpread(_objectSpread({}, data), {}, {\n    helpers: transformedHelpers\n  })).replace(/[ \\n\\r\\t\\f\\xA0]+/g, function (spaces) {\n    return spaces.replace(/(^|\\xA0+)[^\\xA0]+/g, '$1 ');\n  }).trim();\n}\n\nexport default renderTemplate;","map":null,"metadata":{},"sourceType":"module"}